#= 
AA 228 Final Project 
Colton Crosby, William Ho, Kevin Murillo
=#

# code referenced: https://github.com/Erionis/Kuhn_Poker_CFR/blob/main/CFR_Kuhn.ipynb


using Random
using Distributions
using DataStructures
using Plots
using StatsBase
using PrettyTables

const NUM_ACTIONS = 2
const NUM_CARDS   = 3
const NUM_PLAYERS = 2

mutable struct InfoSet
    key 
    regret_sum::Vector{Float64}
    strategy_sum::Vector{Float64}
    strategy::Vector{Float64}
    reach_pr
    reach_pr_sum
    card_val
end

function next_strategy(infoset::InfoSet)
    infoset.strategy_sum += infoset.reach_pr * infoset.strategy
    infoset.strategy = get_strategy(infoset)
    infoset.reach_pr_sum += infoset.reach_pr # add reach probability to sum
    infoset.reach_pr = 0 # reset reach probability
end

function get_strategy(infoset::InfoSet)::Vector{Float64}
    # Compute the strategy using regrets
    positive_regrets = max.(infoset.regret_sum, 0.0)
    normalizing_sum = sum(positive_regrets)

    if normalizing_sum > 0
        strategy = positive_regrets / normalizing_sum
    else
        strategy = fill(1.0 / NUM_ACTIONS, NUM_ACTIONS) # Uniform strategy
    end
    return strategy
end

function get_average_strategy(infoset::InfoSet)::Vector{Float64}
    strategy = infoset.strategy_sum / infoset.reach_pr_sum 
    strategy = ifelse.(strategy .< 0.001, 0, strategy) # remove negligible strategies 
    normalizing_sum = sum(strategy)
    strategy /= normalizing_sum
    return strategy
end

function card2str(card) 
    if card == 1
        return "J" 
    elseif card == 2
        return "Q" 
    elseif card ==3
        return "K"
    else
        error("CARD NOT CODED")
    end
end

function get_infoset(i_map, card, history, p1_strat=0, p2_strat=0) 
    key = join([card2str(card), history])
    # infoset = nothing
    
    if haskey(i_map, key) == 0
        init_regret_sum = zeros(NUM_ACTIONS)
        init_strategy_sum = zeros(NUM_ACTIONS)
        numac_vec = ones(NUM_ACTIONS)
        init_strategy = numac_vec/length(numac_vec)
        init_reach_pr = 0
        init_reach_pr_sum = 0
        card_val = card
        infoset = InfoSet(key, init_regret_sum, init_strategy_sum, init_strategy, init_reach_pr, init_reach_pr_sum,card_val)
        i_map[key] = infoset 
        return infoset
    end

    # println(opp_strat)
    if p2_strat !== 0
        if length(key) % 2 == 0
            strat = p2_strat[key]
            i_map[key].strategy = strat
        end
    end 

    if p1_strat !== 0
        if length(key) % 2 !== 0
            strat = p1_strat[key]
            i_map[key].strategy = strat
        end
    end 
    # @info i_map[key]
    return i_map[key]
    # println(i_map[key])
    
end

function cfr(i_map, p1_strat, p2_strat, history="", card_1=-1, card_2=-1, pr_1=1, pr_2=1, pr_c=1)
    """
    Counterfactual regret minimization algorithm.

    Parameters
    ----------
    i_map: information set dictionary
    history : [{'r', 'c', 'b'}], string representing the path taken in the game tree
    'r': random chance action
    'c': check action
    'b': bet action
    card_1 : player 1's card
    card_2 : player 2's card
    pr_1 : Probability that player 1 reaches history
    pr_2 : Probability that player 2 reaches history
    pr_c: Probability contribution of the chance node to reach history
    """

    if is_chance_node(history)
        return chance_util(i_map, p1_strat, p2_strat)
    end

    if is_terminal(history)
        return terminal_util(history, card_1, card_2)
    end

    n = length(history) 
    is_player_1 = n%2 ==0 # is player 1 logical
    if is_player_1
        # println("player 1: ")
        card = card_1
    else
        # println("player 2: ")
        card = card_2
    end
    # get infoset for current player card
    infoset = get_infoset(i_map, card, history, p1_strat, p2_strat)
    key = join([card2str(card), history])
    strategy = infoset.strategy
        # if is_player_1
        #     if 
        #         p1_strat
        #     else
        #         p2_strat
        #     end
            
        # else # player 2 turn
        #     if p2_strat == 0
        #         strategy = infoset.strategy
        #     else
        #         strategy = p2_strat[key]
        #     end
        # end
    # println("history: ", key, " strat ", strategy)
    # reach probability update
    # println("reach_pr before ", infoset.reach_pr, " sum: ", infoset.reach_pr_sum)
    if is_player_1
        infoset.reach_pr += pr_1 
    else
        infoset.reach_pr += pr_2 
    end
    # println("pr_1 = ", pr_1, ", pr_2 = ", pr_2, ", pr_c = ", pr_c)
    # println("After: ", infoset.key, " ReachProb:  ", infoset.reach_pr, " Summed: ", infoset.reach_pr_sum)
    # initialize counterfactual utilities over actions
    action_utils = zeros(NUM_ACTIONS)
    # p2_action_utils = zeros(NUM_ACTIONS)
    
    # recurse CFR over actions
    for (i, action) in enumerate(["c","b"])
        next_history = join([history, action])

        if is_player_1
            action_utils[i] = -1 * cfr(i_map, p1_strat, p2_strat, next_history,
                                        card_1, card_2, 
                                        pr_1*strategy[i],pr_2,pr_c)
        else
            action_utils[i] = -1 * cfr(i_map, p1_strat, p2_strat, next_history,
                                        card_1, card_2, 
                                        pr_1, pr_2*strategy[i], pr_c)
        end
    end

    ev = sum(action_utils .* strategy)
    regrets = action_utils .- ev

    # p2_ev  = sum(p2_action_utils .* strategy)
    # p2_regrets = p2_action_utils .- p2_ev
    
    # println("ev: ", ev)
    # println("regrets: ", regrets)

    if is_player_1
        infoset.regret_sum += pr_2 * pr_c * regrets
    else
        infoset.regret_sum += pr_1 * pr_c * regrets
    end
    return ev
    # println("regret_sum: ", infoset.regret_sum)
    # println("ev: ", ev)
    
end

function is_chance_node(history)
    return (history == "") # history is empty if chance node
end

function chance_util(i_map, p1_strat,p2_strat)
    ev = 0
    n_possible = NUM_CARDS * NUM_PLAYERS
    for i in 1:NUM_CARDS
        for j in 1:NUM_CARDS
            if i != j 
                ev += cfr(i_map, p1_strat,p2_strat, "  ", i, j, 1, 1, 1/n_possible)
            end
        end
    end
    return ev/n_possible
end

function is_terminal(history)
    if history[end-1:end] == "cc"
        # round ends when both players check (pass)
        return true 
    elseif history[end-1:end] == "bb" 
        # round ends when both players bet (bets are called)
        return true
    elseif history[end-1:end] == "bc"
        # round ends when a player folds after a bet
        return true
    else 
        return false
    end
end

function terminal_util(history, card_1, card_2)
    n = length(history)
    if n % 2 ==0 # card 1 is player 1
        card_player = card_1
        card_opponent = card_2
    else # player 2 turn, card 1 is player 2
        card_player = card_2
        card_opponent = card_1
    end

    if history[end-1:end] == "bc"
        # fold after bet (no showdown, current player wins 1)
        return 1.0
    elseif history[end-1:end] == "cc"
        # two checks, high card wins
        if card_player > card_opponent
            return 1.0
        else 
            return -1.0
        end
    elseif history[end-1:end] == "bb"
        # double bet 
        if card_player > card_opponent
            return 2.0
        else 
            return -2.0
        end
    end
end

function displayStrategy(i_map)
    # sorted = sort(i_map)
    i_map = sort(i_map)
    
    println("First-turn Strategies")
    println("Infoset [Pass, Bet]")
    for (key, infoset) in i_map
        # println(key," ", infoset)
        strat = get_average_strategy(infoset)
        if length(key) % 2 !== 0
            
            println(key, " : [", round(strat[1], digits = 3), ", ", round(strat[2], digits = 3),"]")
        end
    end 
    println(" ")
    println("Second-turn Strategies")
    println("Infoset [Pass, Bet]")
    for (key, infoset) in i_map
        strat = get_average_strategy(infoset)
        if length(key) % 2 == 0
            println(key, " : [", round(strat[1], digits = 3), ", ", round(strat[2], digits = 3),"]")
        end
    end
end



function train(i_map, n_iterations, p1_strat=0, p2_strat=0)

egv = zeros(n_iterations)
is_player_1 = zeros(n_iterations)
p1_egv = zeros(n_iterations รท 2)
p2_egv = zeros(n_iterations รท 2)

    for i in 1:n_iterations 
        egv[i] = cfr(i_map, p1_strat, p2_strat) 
        for (key, infoset) in i_map
            # println(key," ", infoset)
            next_strategy(infoset)
        end 
        # println(i)
    end
    
    displayStrategy(i_map)
    return egv
    # return i_map
end


# # # # # # # # # # # # # # # # # # # # # # # # # # # #
function simulateGame(p1_strategy, p2_strategy)
    deck = Array(Int64(1):Int64(NUM_CARDS)) # create deck

    index = rand(1:length(deck))
    p1_card_val = deck[index]         # player 1 draw
    p1_card = card2str(p1_card_val)
    deleteat!(deck, index)

    index = rand(1:length(deck))
    p2_card_val = deck[index]         # player 2 draw
    p2_card = card2str(p2_card_val)
    deleteat!(deck, index)
    c_card = card2str(deck[1])              # community card
    history = "" # initialize history empty

    # player 1 takes action
    p1_key = join([p1_card, "  "])
    p2_key = join([p2_card, "  "])
        # println("Player 1 draws ", p1_key, " corresponding to strategy ", p1_strategy[p1_key])
    p1_a1 = action2str(rand(Categorical(p1_strategy[p1_key]))) # sample action from strat
        # println("Player 1 takes action ", p1_a1)
        history = join([history,p1_a1])
    p1_key = join([p1_key,p1_a1])
    p2_key = join([p2_key,p1_a1])
        # println("Player 2 has the infoset ", p2_key, " corresponding to strategy ", p2_strategy[p2_key])
    p2_a1 = action2str(rand(Categorical(p2_strategy[p2_key])))
        # println("Player 2 takes the action ", p2_a1)
        history = join([history,p2_a1])
    p1_key = join([p1_key,p2_a1])

    if is_terminal(p1_key)
        p1_return = showdown(history, p1_card_val, p2_card_val)
            # println("terminal at ", history)
            # println("Player utilities [p1, p2]: ", [p1_return, p1_return])
    else
        p1_a2 = action2str(rand(Categorical(p1_strategy[p1_key])))
        history = join([history,p1_a2])
        p1_return = showdown(history, p1_card_val, p2_card_val)
            # println("Player 1 now has the infoset ", p1_key, " corresponding to strategy ", p1_strategy[p1_key])
            # println("Player 1 takes the action ", p1_a2)
            # println("Player utilities [p1, p2]: ", [p1_return, -p1_return])
    end
    return p1_return
end

function showdown(history, p1_card, p2_card)
    if history[end-1:end] == "bc"
        # fold after bet (no showdown, current player wins 1)
        return 1.0
    elseif history[end-1:end] == "cc"
        # two checks, high card wins
        if p1_card > p2_card
            return 1.0
        else 
            return -1.0
        end
    elseif history[end-1:end] == "bb"
        # double bet 
        if p1_card > p2_card
            return 2.0
        else 
            return -2.0
        end
    end
end

function action2str(a)
    if a == 1
        return "c"
    elseif a ==2
        return "b"
    end
end


function tournament(player_strat,opp_strat,n_iterations)
    player_return = zeros(n_iterations)
    for  i = 1:n_iterations
        if i%2 == 0
            player_return[i] = simulateGame(player_strat, opp_strat)
        else
            player_return[i] = -simulateGame(opp_strat, player_strat)
        end
    end
    return player_return
end


# # # # # # # # # # # # # # # # # # # # # # # # # # # #
# save strategies

# GTO from CFR
GTO_strat = Dict("J  "   => [0.793, 0.207],
                 "J  cb" => [1.0, 0.0],
                 "K  "   => [0.375, 0.625],
                 "K  cb" => [0.0, 1.0],
                 "Q  "   => [1.0, 0.0],
                 "Q  cb" => [0.459, 0.541],
                 "J  b" => [1.0, 0.0],
                 "J  c" => [0.666, 0.334],
                 "K  b" => [0.0, 1.0],
                 "K  c" => [0.0, 1.0],
                 "Q  b" => [0.666, 0.334],
                 "Q  c" => [1.0, 0.0])


# random strats
random_strat = Dict("J  "   => [0.5, 0.5],
                    "J  cb" => [0.5, 0.5],
                    "K  "   => [0.5, 0.5],
                    "K  cb" => [0.5, 0.5],
                    "Q  "   => [0.5, 0.5],
                    "Q  cb" => [0.5, 0.5],
                    "J  b" => [0.5, 0.5],
                    "J  c" => [0.5, 0.5],
                    "K  b" => [0.5, 0.5],
                    "K  c" => [0.5, 0.5],
                    "Q  b" => [0.5, 0.5],
                    "Q  c" => [0.5, 0.5])

# 90 bet 
bet90_strat = Dict("J  "   => [0.1, 0.9],
                    "J  cb" => [0.1, 0.9],
                    "K  "   => [0.1, 0.9],
                    "K  cb" => [0.1, 0.9],
                    "Q  "   => [0.1, 0.9],
                    "Q  cb" => [0.1, 0.9],
                    "J  b" => [0.1, 0.9],
                    "J  c" => [0.1, 0.9],
                    "K  b" => [0.1, 0.9],
                    "K  c" => [0.1, 0.9],
                    "Q  b" => [0.1, 0.9],
                    "Q  c" => [0.1, 0.9])

# 90% pass# 90 bet 
check90_strat = Dict("J  "   => [0.9, 0.1],
                    "J  cb"  => [0.9, 0.1],
                    "K  "    => [0.9, 0.1],
                    "K  cb"  => [0.9, 0.1],
                    "Q  "    => [0.9, 0.1],
                    "Q  cb"  => [0.9, 0.1],
                    "J  b"   => [0.9, 0.1],
                    "J  c"   => [0.9, 0.1],
                    "K  b"   => [0.9, 0.1],
                    "K  c"   => [0.9, 0.1],
                    "Q  b"   => [0.9, 0.1],
                    "Q  c"   => [0.9, 0.1])
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
## train player 1 against opponent strategies with CFR
#=
i_map = Dict()
n_iterations = 10000

p1_strat = 0 # default CFR self play
# p2_strat = 0 # default CFR self play
egv = train(i_map, n_iterations, p1_strat, p2_strat);
println(" ")
println("Player 1 Expected Game Value: ", sum(egv)/n_iterations)
println("Player 2 Expected Game Value:  ", sum(-egv)/n_iterations)
=#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
## run tournaments
#
n_games = 10000
play_strat = GTO_strat
oppo_strat = check90_strat
player_return = tournament(play_strat,oppo_strat,n_games)
player_sum = sum(player_return)

println("Player vs Opponent: ", player_sum,", ",-player_sum)
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #